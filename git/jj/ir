#!/usr/bin/env python3
"""Interactive rebase for jj - clean Python implementation"""

import subprocess
import sys
import tempfile
import os
import signal
import re
import argparse
from typing import List, Optional, Union, NewType
from dataclasses import dataclass, field


# Strong types for semantic strings
ChangeId = NewType('ChangeId', str)
Bookmark = NewType('Bookmark', str)
Message = NewType('Message', str)
OperationId = NewType('OperationId', str)


@dataclass
class Commit:
    """Represents a commit with its metadata"""
    change_id: ChangeId
    message: Message
    bookmarks: List[Bookmark] = field(default_factory=list)


@dataclass
class CommitItem:
    """Represents a commit in the edited rebase plan"""
    change_id: ChangeId
    message: Message
    squash: bool = False
    bookmarks: List[Bookmark] = field(default_factory=list)


@dataclass
class BreakItem:
    """Represents a break point in the rebase plan"""
    pass


RebaseItem = Union[CommitItem, BreakItem]


class InteractiveRebase:
    def __init__(self, target_branch: str = 'main', verbose: bool = False) -> None:
        self.target_branch: str = target_branch
        self.verbose: bool = verbose
        self.original_op_id: Optional[OperationId] = None
        
    def jj_cmd(self, *args: str, permit_stderr = False) -> subprocess.CompletedProcess[str]:
        """Run jj command with optional verbose output"""
        cmd: List[str] = ['jj'] + list(args)
        if self.verbose:
            print(f"> jj {' '.join(args)}", file=sys.stderr)
        
        result: subprocess.CompletedProcess[str] = subprocess.run(
            cmd, capture_output=True, text=True, check=False
        )
        if result.returncode != 0 or (result.stderr and not permit_stderr):
            print(f"JJ command failed: {result}", file=sys.stderr)
            self.abort_rebase()
        return result
            
    def get_log_content(self) -> str:
        """Get commit log from target_branch to @"""
        template: str = (
            'if(local_bookmarks.len() > 0, '
            '"\\nBOOKMARK " ++ local_bookmarks.join(" ") ++ "\\n") ++ '
            'change_id.short() ++ ": " ++ description.first_line() ++ "\\n"'
        )
        result: subprocess.CompletedProcess[str] = self.jj_cmd(
            'log', '--quiet', '--no-graph', '-r', 
            f'{self.target_branch}..@', '-T', template
        )
        return result.stdout
        
    def parse_log_to_commits(self, content: str) -> List[Commit]:
        """Parse log content into list of commits with bookmarks"""
        commits: List[Commit] = []
        pending_bookmarks: List[Bookmark] = []
        
        for line in content.strip().split('\n'):
            if not line:
                continue
                
            if line.startswith('BOOKMARK '):
                # Save bookmarks for the next commit we see
                bookmark_names: List[str] = line[9:].split()
                pending_bookmarks = [Bookmark(b.rstrip('*')) for b in bookmark_names]
            elif ':' in line:
                match: Optional[re.Match[str]] = re.match(r'^([a-z]{12}):\s*(.*)$', line)
                if match:
                    change_id_str: str
                    message_str: str
                    change_id_str, message_str = match.groups()
                    commit = Commit(
                        change_id=ChangeId(change_id_str),
                        message=Message(message_str),
                        bookmarks=pending_bookmarks
                    )
                    commits.append(commit)
                    pending_bookmarks = []  # Reset for next commit
                    
        return commits
        
    def format_commits_for_edit(self, commits: List[Commit]) -> str:
        """Format commits for editing"""
        lines: List[str] = []
        for i, commit in enumerate(commits):
            # Add blank line before bookmarks (except for the first commit)
            if i > 0 and commit.bookmarks:
                lines.append('')
            
            if commit.bookmarks:
                lines.append(f"BOOKMARK {' '.join(commit.bookmarks)}")
            lines.append(f"{commit.change_id}: {commit.message}")
        return '\n'.join(lines)
        
    def parse_edited_plan(self, content: str) -> List[RebaseItem]:
        """Parse edited rebase plan"""
        items: List[RebaseItem] = []
        pending_bookmarks: List[Bookmark] = []
        
        for line in content.split('\n'):
            line = line.rstrip()
            
            if not line or line.startswith('//'):
                continue
                
            if line == 'b':
                items.append(BreakItem())
                pending_bookmarks = []  # Clear any pending bookmarks
                continue
                
            if line.startswith('BOOKMARK '):
                # Save bookmarks for the next commit we see
                bookmark_names: List[str] = line[9:].split()
                pending_bookmarks = [Bookmark(b.rstrip('*')) for b in bookmark_names]
                continue
                
            match: Optional[re.Match[str]] = re.match(r'^(s\s+)?([a-z]{12}):\s*(.*)$', line)
            if match:
                squash_prefix: Optional[str]
                change_id_str: str
                message_str: str
                squash_prefix, change_id_str, message_str = match.groups()
                commit_item = CommitItem(
                    change_id=ChangeId(change_id_str),
                    message=Message(message_str),
                    squash=bool(squash_prefix),
                    bookmarks=pending_bookmarks
                )
                items.append(commit_item)
                pending_bookmarks = []  # Reset for next commit
                continue

            print('Invalid line in rebase plan: ', line, file=sys.stderr)
            self.abort_rebase()
                
        return items
        
    def edit_plan(self, formatted_content: str) -> str:
        """Let user edit the rebase plan"""
        editor: str = os.environ.get('EDITOR', 'nvim')
        
        with tempfile.NamedTemporaryFile(mode='w', suffix='.txt', delete=False) as f:
            f.write("// Reorder any change or bookmark line to rearrange them during the rebase.\n")
            f.write("// Modify any change description to update it.\n")
            f.write("// Add the prefix 's ' to any change line to squash into the following change.\n")
            f.write("// Add a standalone 'b' line to break and manually edit inline.\n\n")
            f.write(formatted_content)
            tmpfile: str = f.name
            
        try:
            result: subprocess.CompletedProcess[bytes] = subprocess.run([editor, tmpfile])
            if result.returncode != 0:
                print(f"Editor exited with code {result.returncode}. Cancelled rebase.", file=sys.stderr)
                sys.exit(1)
                
            with open(tmpfile, 'r') as f:
                return f.read()
        finally:
            os.unlink(tmpfile)
            
    def abort_rebase(self, signum: Optional[int] = None, frame: object = None) -> None:
        """Abort the rebase by restoring to original operation"""
        if self.original_op_id:
            print("Aborting rebase...", file=sys.stderr)
            cmd: List[str] = ['jj', 'op', 'restore', self.original_op_id]
            print(f"> {' '.join(cmd)}", file=sys.stderr)
            result: subprocess.CompletedProcess[str] = subprocess.run(
                cmd, capture_output=True, text=True, check=False
            )
            if result.returncode == 0:
                print("Rebase aborted successfully.", file=sys.stderr)
            else:
                print(f"Failed to abort rebase: {result}", file=sys.stderr)
        sys.exit(1)
        
    def run(self) -> None:
        # Set up signal handler for Ctrl-C
        signal.signal(signal.SIGINT, self.abort_rebase)
        
        # Get original operation ID
        result: subprocess.CompletedProcess[str] = self.jj_cmd(
            'op', 'log', '--limit', '1', '--no-graph', '--template', 'id.short()'
        )
        self.original_op_id = OperationId(result.stdout.strip())
        
        print(f"Interactive rebase starting. To revert, run: jj op restore {self.original_op_id}")
        
        # Get original log content
        log_content: str = self.get_log_content()
        original_commits: List[Commit] = self.parse_log_to_commits(log_content)
        
        # Build lookup for original state
        original_state: dict[ChangeId, Commit] = {
            c.change_id: c for c in original_commits
        }
        
        # Format and let user edit
        formatted: str = self.format_commits_for_edit(original_commits)
        edited_content: str = self.edit_plan(formatted)
        edited_plan: List[RebaseItem] = self.parse_edited_plan(edited_content)
        
        # If all lines deleted, do nothing
        if not edited_plan:
            print("All lines in rebase plan deleted. Skipping rebase.", file=sys.stderr)
            sys.exit(0)
            
        # Process from bottom to top (reverse since log is newest-first)
        prev_commit: str = self.target_branch

        all_original_bookmarks = {
            bookmark 
            for item in original_commits 
            for bookmark in item.bookmarks
        }
        
        for item in reversed(edited_plan):
            if isinstance(item, BreakItem):
                # Edit to the current position before breaking
                self.jj_cmd('edit', prev_commit, '--quiet')
                result = self.jj_cmd('log', '-r', '@', '--no-graph', '-T', 
                                     'change_id.short() ++ " " ++ committer.email() ++ " " ++ committer.timestamp() ++ " " ++ bookmarks ++ " " ++ " " ++ description')
                current_info = result.stdout.strip()
                
                print(f"Rebase paused...")
                print(f"HEAD: {current_info}")
                print("Press Enter to continue rebase after manual edits, or Ctrl-C to abort...")
                input()  # Signal handler will catch Ctrl-C
                
                # After break, get the actual current commit (user may have created new commits)
                result = self.jj_cmd('log', '-r', '@', '--no-graph', '-T', 
                                     'change_id.short() ++ " " ++ committer.email() ++ " " ++ committer.timestamp() ++ " " ++ bookmarks ++ " " ++ " " ++ description')
                current_info = result.stdout.strip()
                current = current_info.split(' ')[0]
                
                print(f"Rebase resuming from HEAD: {current_info}")
                
                # Continue from current position
                prev_commit = current
                continue
                
            # Process commit (must be CommitItem now)
            assert isinstance(item, CommitItem)
            change_id: ChangeId = item.change_id
            
            # 1. Rebase onto previous commit
            already_rebased_result = self.jj_cmd('log', '-r', f'{change_id}- & {prev_commit}', '--no-graph', '-T', 'change_id.short()')
            already_rebased = bool(already_rebased_result.stdout.strip())

            if not already_rebased:
                self.jj_cmd('rebase', '-r', change_id, '--onto', prev_commit, '--quiet')
            
            # 2. Update message if changed
            original: Optional[Commit] = original_state.get(change_id)
            if original and item.message != original.message:
                self.jj_cmd('describe', '--message', item.message, change_id, '--quiet')
                
            # 3. Move bookmarks if they're new to this commit
            if original:
                original_bookmarks: set[Bookmark] = set(original.bookmarks)
                new_bookmarks: set[Bookmark] = set(item.bookmarks)
                
                for bookmark in new_bookmarks:
                    if bookmark not in original_bookmarks:
                        self.jj_cmd('bookmark', 'set', '--allow-backwards', 
                                   bookmark, '--to', change_id, '--quiet')
                        if bookmark not in all_original_bookmarks:
                            self.jj_cmd('bookmark', 'track', f'{bookmark}@origin', permit_stderr=True)
                        
            # 4. Squash if marked (into previous commit which is its parent)
            if item.squash:
                self.jj_cmd('squash', '-r', change_id, '--use-destination-message', '--quiet')
                # Don't update prev_commit - this commit was squashed away
            else:
                # This commit becomes the new base for the next one
                prev_commit = change_id
        
        # Find the topmost non-squashed commit and edit to it
        new_head: Optional[ChangeId] = None
        for item in edited_plan:
            if isinstance(item, CommitItem) and not item.squash:
                new_head = item.change_id
                break
                
        if new_head:
            self.jj_cmd('edit', new_head, '--quiet')
            
        print(f"Interactive rebase completed. To revert, run: jj op restore {self.original_op_id}")


def main() -> None:
    parser: argparse.ArgumentParser = argparse.ArgumentParser(description='Interactive rebase for jj')
    parser.add_argument('target_branch', nargs='?', default='main', 
                       help='Target branch to rebase onto (default: main)')
    parser.add_argument('--verbose', '-v', action='store_true', 
                       help='Print each jj command as it runs')
    
    args: argparse.Namespace = parser.parse_args()
    
    rebase: InteractiveRebase = InteractiveRebase(args.target_branch, args.verbose)
    rebase.run()


if __name__ == '__main__':
    main()
