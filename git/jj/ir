#!/usr/bin/env bash
set -u

: "${EDITOR:=nvim}"

log_content=$(jj log --quiet --no-graph -r "main..@" -T '
if(local_bookmarks.len() > 0,
    "BOOKMARK " ++ local_bookmarks.join(" ") ++ "\n"
) ++
change_id.short() ++ ": " ++ description.first_line() ++ "\n\n"
')
ret=$?
if [ $ret -ne 0 ]; then
    echo "Cancelled interactive rebase because we are not in a jj repo."
    exit 1
fi

original_tmpfile=$(mktemp /tmp/jj_rebase_original.XXXXXX)
echo "$log_content" >> "$original_tmpfile"

tmpfile=$(mktemp /tmp/jj_rebase.XXXXXX)
printf "// Reorder any change or bookmark line to rearrange them during the rebase.\n" >> $tmpfile
printf "// Modify any change description to update it.\n" >> $tmpfile
printf "// Add the prefix 's ' to any change line to squash into the following change.\n\n" >> $tmpfile
printf "%s\n\n" "$log_content" >> "$tmpfile"

"$EDITOR" "$tmpfile"
ret=$?

if [ $ret -ne 0 ]; then
    echo "Editor exited with code $ret. Cancelled rebase."
    rm -f "$tmpfile"
    exit 1
fi

validate_file() {
    local file=$1
    local lineno=0

    while IFS= read -r line || [ -n "$line" ]; do
        lineno=$((lineno + 1))

        [[ -z "$line" ]] && continue
        [[ "$line" =~ ^// ]] && continue

        [[ "$line" =~ ^BOOKMARK\ [-_/A-Za-z0-9*]+([[:space:]]+[-_/A-Za-z0-9*]+)*$ ]] && continue
        [[ "$line" =~ ^s\ [a-z]{12}:\ .+ ]] && continue
        [[ "$line" =~ ^[a-z]{12}:\ .+ ]] && continue

        echo "Invalid line \"$line\"" >&2
        echo "Aborted rebase." >&2
        return 1
    done < "$file"
}

validate_file "$tmpfile" || exit 1

set -e

most_recent_op_id=$(jj op log --limit 1 --no-graph --template "id.short()")
most_recent_head=$(jj log -r @ --no-graph --template "change_id.short()")

printf "Interactive rebase starting. If you would like to revert this rebase, run \"jj op restore $most_recent_op_id\".\n"

trap 'echo "Encountered error - reverting rebase." && jj op restore "$most_recent_op_id"' ERR

################################
# Phase 1: rebase bottom → top #
################################

original_commits=$(
  grep ':' "$original_tmpfile" |
  sed 's/^s[[:space:]]\+//' |
  cut -d: -f1
)

declare -A original_commit_to_prev_commit
prev="main"
while read -r commit; do
    commit=${commit#s }
    original_commit_to_prev_commit["$commit"]="$prev"
    prev="$commit"
done < <(
    printf "%s\n" "$original_commits" |
    awk '{ a[NR]=$0 } END { for (i=NR;i>=1;i--) print a[i] }'
)

commits=$(
  grep ':' "$tmpfile" |
  sed 's/^s[[:space:]]\+//' |
  cut -d: -f1
)

prev="main"
while read -r commit; do
    commit=${commit#s }
    original_prev_commit="${original_commit_to_prev_commit[$commit]}"
    if [ "$original_prev_commit" != "$prev" ]; then
      jj rebase -r "$commit" --insert-after "$prev" --quiet --ignore-working-copy
    fi
    prev="$commit"
done < <(
    printf "%s\n" "$commits" |
    awk '{ a[NR]=$0 } END { for (i=NR;i>=1;i--) print a[i] }'
)

################################
# Phase 2: move bookmarks      #
# bottom → top                 #
################################

declare -A bookmark_to_original_commit

last_commit=""
while read -r line; do
    case "$line" in
        *:*)
            # strip optional "s "
            line=${line#s }
            last_commit=${line%%:*}
            ;;
        BOOKMARK\ *)
            [ -n "$last_commit" ] || continue
            bookmark_list=${line#BOOKMARK }
            for bookmark in $bookmark_list; do
              bookmark="${bookmark%\*}"
              bookmark_to_original_commit["$bookmark"]="$last_commit"
            done
            ;;
    esac
done < <(
  awk '{ a[NR]=$0 } END { for (i=NR;i>=1;i--) print a[i] }' "$original_tmpfile"
)

last_commit=""
while read -r line; do
    case "$line" in
        *:*)
            # strip optional "s "
            line=${line#s }
            last_commit=${line%%:*}
            ;;
        BOOKMARK\ *)
            [ -n "$last_commit" ] || continue
            bookmark_list=${line#BOOKMARK }
            for bookmark in $bookmark_list; do
              bookmark="${bookmark%\*}"
              original_commit="${bookmark_to_original_commit[$bookmark]}"
              if [ "$original_commit" != "$last_commit" ]; then
                jj bookmark move --allow-backwards "$bookmark" --to "$last_commit" --quiet --ignore-working-copy
              fi
            done
            ;;
    esac
done < <(
  awk '{ a[NR]=$0 } END { for (i=NR;i>=1;i--) print a[i] }' "$tmpfile"
)


################################
# Phase 3: squash bottom → top #
################################

while read -r commit; do
    commit=${commit#s }
    jj squash -r $commit --use-destination-message --quiet --ignore-working-copy
done < <(
  grep '^[[:space:]]*s[[:space:]]\+[^:]\+:' "$tmpfile" |
  sed 's/^[[:space:]]*s[[:space:]]\+//' |
  cut -d: -f1 |
  awk '{ a[NR]=$0 } END { for (i=NR;i>=1;i--) print a[i] }'
)


#################################
# Phase 4: update change messages
#################################

while read -r line; do
    case "$line" in
        s\ *) continue ;;
    esac

    case "$line" in
        *:*)
            commit=${line%%:*}
            message=${line#*: }
            rg --quiet "^$commit.*$message$" "$original_tmpfile" || jj describe --message "$message" "$commit" --quiet --ignore-working-copy
            ;;
    esac
done < <(
  awk '{ a[NR]=$0 } END { for (i=NR;i>=1;i--) print a[i] }' "$tmpfile"
)

new_head=$(grep -v '^s ' "$tmpfile" | grep ':' | head -n1 | cut -d: -f1)
jj edit $new_head --quiet

printf "Interactive rebase completed.\n"
